OpenId Connect — это дополнительный уровень~\cite{siriwardenaOpenid2020, sakimuraOpenid2014} идентификации поверх протокола~\cite{hardt2012oauth} OAuth 2.0.
Он позволяет клиентам проверять личность конечного пользователя на основе аутентификации,
а также получать базовую информацию профиля конечного пользователя.

OAuth 2.0 — это протокол, позволяющий стороннему приложению получить ограниченный доступ к HTTP-сервису, либо от имени владельца ресурса,
организуя взаимодействие по утверждению между владельцем ресурса и HTTP-сервисом, либо путем разрешения стороннему приложению получить
доступ от своего имени.

OAuth 2.0 предоставляет различные стандартизированные потоки сообщений, основанные на JSON и HTTP; OpenID Connect использует их для предоставления
услуг идентификации.

В традиционной модели аутентификации клиент-сервер, клиент запрашивает ресурс с ограниченным доступом
через аутентификацию с использованием пары логин-пароль.
Для того чтобы предоставить сторонним приложениям доступ к ресурсам,
владелец ресурса (пользователь) делится своими учетными данными (логином и паролем) со сторонним приложением.
Этот подход создает ряд проблем и ограничений~\cite{hardt2012oauth}:
\begin{itemize}
    \item Сторонние приложения должны хранить учетные данные (логин и пароль) владельца ресурса для дальнейшего использования,
    бывает так, что пароль хранится в явном виде в базе данных.
    \item Сторонние приложения обязаны поддерживать аутентификацию с помощью пароля, несмотря на недостатки безопасности, присущие паролям.
    \item Сторонние приложения получают полный доступ к защищенным ресурсам владельца ресурса (пользователя),
    оставляя владельцев ресурсов без какой-либо возможности ограничить продолжительность доступа или подмножество доступных ресурсов (scope).
    \item Владельцы ресурсов (пользователи) не могут отозвать доступ к отдельному третьему лицу без отзыва доступа для всех третьих лиц,
    и должны отозвать доступ только путем изменения пароля.
    \item Взлом либо утечка данных из любого стороннего приложения приводит к потере пароля конечного пользователя и всех данных,
    защищенных этим паролем.
\end{itemize}

OAuth 2.0 решает эти проблемы путем введения уровня авторизации и разделения роли клиента (сервис авторизации) и владельца ресурса (пользователя).
В OAuth 2.0 клиент запрашивает доступ к ресурсам, контролируемым владельцем ресурса и размещенным на сервере ресурса.
Вместо того чтобы использовать учетные данные владельца ресурса для доступа к защищенным ресурсам, клиент получает токен доступа.

OAuth 2.0 with the Proof of Key Code Exchange~\cite{bradley2015rfc} flow показан ниже
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/OAuthPkceScheme_1570_1055}
    ~\caption{OAuth 2.0 with PKCE flow diagram.}
\end{figure}

\begin{enumerate}
    \item После нажатия на кнопку \texttt{Sign in with Google} происходит перенаправление на ендпоинт авторизации,
    на котором владелец ресурса должен ввести свои учетные данные, а так же согласиться с некоторыми условиями.
    Особое внимание стоит обратить на code\_challenge и code\_challenge\_method, первое представляет собой некоторую строку,
    которая будет закодирована с помощью метода кодировки указанного в параметре запроса code\_challenge\_method.
    В дальнейшем, при обмене полученного кода на токен доступа и обновления, мы должны будем предъявить значение code\_verifier,
    которое равно ранее закондированному code\_challenge.
    \item После успешной аутентификации, произойдет перенаправление на адресс \texttt{redirect\_uri}.
    \item После получения авторизационного кода происходит обмен этого кода на токены доступа (access token) и обновления (refresh token).
    Если ранее, при переадресации владельца ресурса на авторизационный ендпоинт, мы указывали \texttt{code\_challenge} и \texttt{code\_challenge\_method},
    то теперь, при обмене кода на токены, мы обязаны передать в запросе значение \texttt{code\_verifier}.
\end{enumerate}
Здесь мы упоминаем такие определения, как code и state, и они означают
\begin{itemize}
    \item \textbf{Code} - это код авторизации, который получается с помощью сервера авторизации и является посредником между клиентов и владельцев ресурса.
    Перед тем как сервер авторизации перенаправит владельца ресурса обратно на клиент, сервер авторизации проверяет подлинность владельца ресурса.
    Так образом поскольку владелец ресурса аутентифицируется только на сервере авторизации, его учетные данные никогда не передадутся клиенту.
    \item \textbf{State} - значение, используемое клиентом для сохранения состояния между запросом на авторизацию и обратным вызовом (callback).
    Сервер авторизации включает это значение при перенаправлении агента пользователя обратно клиенту.
    Этот параметр используется для предотвращения Cross-Site Request Forgery (CSRF) атак.
\end{itemize}

Adding the Proof of Key Code Exchange (PKCE) to the OIDC flow improves protocol security so that the code
cannot be exchanged by third-party applications by-passing the original application.
Authorization code flow with PKCE is a protocol that represents a client-generated secret that can be verified
by an authorization server.
This secret is called \texttt{code\_verifier}.
The client hashes the \texttt{code\_verifier} value and writes it to the \texttt{code\_challenge} parameter
of an HTTP request.
PKCE solves the problem of secure code exchange.
If an attacker manages to get an authorization code, then he will not be able to exchange
it for access and refresh tokens.
Therefore, we ensure that the exchange of a code for tokens is produced by the same application
that performed the authentication.
Proof of Key Code Exchange can be compared to the digital signature of an authentication process.
To exchange the \texttt{code} for a pair of access and refresh tokens, it is necessary to specify
a valid \texttt{code\_verifier}.

Authorization code flow with PKCE является протоколом, который представляет секрет, созданный клиентом,
который может быть проверен сервером авторизации.
Этот секрет называется \texttt{code\_verifier}.
Клиент хеширует значение \texttt{code\_verifier} и записывает его в параметр \texttt{code\_challenge}.
PKCE решает проблему безопасного обмена кода.
Если злоумышленнику удастся заполучить авторизационный код, то у него не получится обменять
его на токены доступа и обновления.
Таким образом, мы гарантируем тот факт, что обмен кода на токены производит то же самое приложение, что и выполняло аутентификацию.
В некотором роде, PKCE можно сравнить с цифровой подписью процесса аутентификации.
При обмене кода авторизации на токены обязательно нужно указать \texttt{code\_verifier}.